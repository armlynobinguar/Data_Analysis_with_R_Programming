library(readr)
# Heads up that the following instruction can generate a column specification warnings, you can ignore that.
# These warnings are related to that `readr` has misguidedly guessed the type of values in the column `Pool QC`. 
# To avoid this warning we can manually specify the type of this column the `col_types` parameter.
houses  <-  read_tsv('AmesHousing_1.txt', col_types = cols(`Pool QC` = col_character())) 

standard_deviation <- function(vector) {
    distances  <-  (vector - mean(vector))**2 
    sqrt(sum(distances) / length(distances) )
}

st_dev  <-  standard_deviation(houses$SalePrice)
mean  <-  mean(houses$SalePrice)

library(ggplot2)
#ggplot(data = houses,
#    aes(x = SalePrice)) +
#    geom_density(alpha = 0.1, 
#                 color='blue', 
#                 fill='blue') +
#    geom_vline(aes(xintercept = mean, 
#                   color = 'Mean'), 
#               size = 1.2 ) +
#    geom_vline(aes(xintercept = 220000, 
#                   color = '220,000'), 
#               size = 1.2 ) +
#    geom_vline(aes(xintercept = mean+st_dev, 
#                   color = 'Standard deviation'), 
#               size = 1.2 ) +
#    scale_y_continuous(labels = scales::comma) +
#    scale_x_continuous(labels = scales::comma, 
#                       lim = c(min(houses$SalePrice), 
#                               max(houses$SalePrice))) +
#    scale_colour_manual(values = c("Mean"="black", 
#                                   "220,000"="red", 
#                                   "Standard deviation"="orange"), 
#                        name = "") +
#    theme_bw() + 
#    theme(legend.position='top') +
#    xlab("Sale Price") + 
#    ylab("Density")
very_expensive  <-  FALSE

library(readr)
# Heads up that the following instruction can generate a column specification warnings, you can ignore that.
# These warnings are related to that `readr` has misguidedly guessed the type of values in the column `Pool QC`. 
# To avoid this warning we can manually specify the type of this column the `col_types` parameter.
houses  <-  read_tsv('AmesHousing_1.txt', col_types = cols(`Pool QC` = col_character())) 

standard_deviation <- function(vector) {
    distances  <-  (vector - mean(vector))**2 
    sqrt(sum(distances) / length(distances) )
}

st_dev  <-  standard_deviation(houses$SalePrice)
mean  <-  mean(houses$SalePrice)

library(ggplot2)
#ggplot(data = houses,
#    aes(x = SalePrice)) +
#    geom_density(alpha = 0.1, 
#                 color='blue', 
#                 fill='blue') +
#    geom_vline(aes(xintercept = mean, 
#                   color = 'Mean'), 
#               size = 1.2 ) +
#    geom_vline(aes(xintercept = 220000, 
#                   color = '220,000'), 
#               size = 1.2 ) +
#    geom_vline(aes(xintercept = mean+st_dev, 
#                   color = 'Standard deviation'), 
#               size = 1.2 ) +
#    scale_y_continuous(labels = scales::comma) +
#    scale_x_continuous(labels = scales::comma, 
#                       lim = c(min(houses$SalePrice), 
#                               max(houses$SalePrice))) +
#    scale_colour_manual(values = c("Mean"="black", 
#                                   "220,000"="red", 
#                                   "Standard deviation"="orange"), 
#                        name = "") +
#    theme_bw() + 
#    theme(legend.position='top') +
#    xlab("Sale Price") + 
#    ylab("Density")
very_expensive  <-  FALSE

standard_deviation <- function(vector) {
    distances  <-  (vector - mean(vector))**2 
    sqrt(sum(distances) / length(distances) )
}
distance  <-  220000 - mean(houses$SalePrice)
st_devs_away  <-  distance / standard_deviation(houses$SalePrice)

min_val  <-  min(houses$SalePrice)
mean_val  <-  mean(houses$SalePrice)
max_val  <-  max(houses$SalePrice) 

standard_deviation <- function(vector) {
    distances  <-  (vector - mean(vector))**2 
    sqrt(sum(distances) / (length(distances) -1) )
}
z_score <- function(value, vector, bessel = FALSE) {
    mean  <-  mean(vector)
    
    st_dev <- ifelse(!bessel, sd(vector), standard_deviation(vector)) 
    
    (value - mean) / st_dev
}

min_z  <-  z_score(min_val, houses$SalePrice)
mean_z  <-  z_score(mean_val, houses$SalePrice)
max_z  <-  z_score(max_val, houses$SalePrice)

standard_deviation <- function(vector) {
    distances  <-  (vector - mean(vector))**2 
    sqrt(sum(distances) / length(distances) )
}

z_score <- function(value, vector, bessel = FALSE) {
    mean  <-  mean(vector)
    
    st_dev <- ifelse(!bessel, sd(vector), standard_deviation(vector)) 
    
    (value - mean) / st_dev
}

target_neighborhoods <- c('NAmes', 'CollgCr', 'OldTown', 'Edwards', 'Somerst')
# Filter only the interesting locations from the dataset
# Group by neighborhood and find the z-score for 200000 for every location
# Sort the result by zcore
library(dplyr)
houses %>%
    filter(Neighborhood %in% target_neighborhoods) %>%
    group_by(Neighborhood) %>%
    summarise(zscore = abs(z_score(200000, SalePrice))) %>%
    ungroup() %>%
    arrange(zscore)

# Find the location with the z-score closest to 0
best_investment  <-  'College Creek'
